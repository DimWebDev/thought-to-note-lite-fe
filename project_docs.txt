Repository Documentation
This document provides a comprehensive overview of the repository's structure and contents.
The first section, titled 'Directory/File Tree', displays the repository's hierarchy in a tree format.
In this section, directories and files are listed using tree branches to indicate their structure and relationships.
Following the tree representation, the 'File Content' section details the contents of each file in the repository.
Each file's content is introduced with a '[File Begins]' marker followed by the file's relative path,
and the content is displayed verbatim. The end of each file's content is marked with a '[File Ends]' marker.
This format ensures a clear and orderly presentation of both the structure and the detailed contents of the repository.

Directory/File Tree Begins -->

thought-to-note-lite-fe/
├── Dockerfile
├── README.md
├── documentation.md
├── public
│   └── index.html
├── src
│   ├── App.tsx
│   ├── api
│   │   └── api.ts
│   ├── components
│   │   ├── notes
│   │   │   ├── Note.tsx
│   │   │   ├── NoteForm.tsx
│   │   │   └── NoteList.tsx
│   │   └── shared
│   │       └── StyledCard.tsx
│   ├── hooks
│   │   └── useNotes.ts
│   ├── index.tsx
│   ├── interfaces
│   │   └── types.ts
│   ├── pages
│   ├── services
│   ├── styles
│   ├── theme
│   │   └── theme.ts
│   └── utils
└── tsconfig.json

<-- Directory/File Tree Ends

File Content Begin -->
[File Begins] Dockerfile

[File Ends] Dockerfile

[File Begins] README.md
# Getting Started with Create React App

This project was bootstrapped with [Create React App](https://github.com/facebook/create-react-app).

## Available Scripts

In the project directory, you can run:

### `npm start`

Runs the app in the development mode.\
Open [http://localhost:3000](http://localhost:3000) to view it in the browser.

The page will reload if you make edits.\
You will also see any lint errors in the console.

### `npm test`

Launches the test runner in the interactive watch mode.\
See the section about [running tests](https://facebook.github.io/create-react-app/docs/running-tests) for more information.

### `npm run build`

Builds the app for production to the `build` folder.\
It correctly bundles React in production mode and optimizes the build for the best performance.

The build is minified and the filenames include the hashes.\
Your app is ready to be deployed!

See the section about [deployment](https://facebook.github.io/create-react-app/docs/deployment) for more information.

### `npm run eject`

**Note: this is a one-way operation. Once you `eject`, you can’t go back!**

If you aren’t satisfied with the build tool and configuration choices, you can `eject` at any time. This command will remove the single build dependency from your project.

Instead, it will copy all the configuration files and the transitive dependencies (webpack, Babel, ESLint, etc) right into your project so you have full control over them. All of the commands except `eject` will still work, but they will point to the copied scripts so you can tweak them. At this point you’re on your own.

You don’t have to ever use `eject`. The curated feature set is suitable for small and middle deployments, and you shouldn’t feel obligated to use this feature. However we understand that this tool wouldn’t be useful if you couldn’t customize it when you are ready for it.

## Learn More

You can learn more in the [Create React App documentation](https://facebook.github.io/create-react-app/docs/getting-started).

To learn React, check out the [React documentation](https://reactjs.org/).

[File Ends] README.md

[File Begins] documentation.md
# Thought-to-Note Lite Frontend Documentation

## Overview

The Thought-to-Note Lite frontend is a React-based web application that allows users to manage their notes. It interacts with a backend service through a RESTful API to perform CRUD (Create, Read, Update, Delete) operations on notes. The frontend is built using TypeScript, React, and Material-UI, with a focus on providing a responsive and user-friendly interface.

### Core Technologies
- **React**: For building the user interface.
- **TypeScript**: For static type checking and better code quality.
- **Material-UI**: For UI components and styling.
- **Emotion**: For CSS-in-JS styling.

## Project Structure

The frontend codebase is organized into several key directories and files to maintain clarity and separation of concerns.

### Directory Structure

```
src/
├── api/
│   └── api.ts                # Centralized API calls
├── components/
│   ├── notes/
│   │   ├── Note.tsx          # Individual Note component
│   │   ├── NoteList.tsx      # List of Notes component
│   │   ├── NoteForm.tsx      # Form for creating/editing notes
│   │   └── index.ts          # Exports for Note components
│   └── shared/
│       ├── Button.tsx        # Shared Button component
│       ├── TextField.tsx     # Shared TextField component
│       └── StyledCard.tsx    # Styled card for notes
├── hooks/
│   └── useNotes.ts           # Custom hook for notes CRUD operations
├── interfaces/
│   └── types.ts              # TypeScript interfaces for types
├── theme/
│   └── theme.ts              # Theme definitions for styling
├── App.tsx                   # Main application component
└── index.tsx                 # Entry point for the React application
```

### Key Components and Files

1. **App.tsx**
   - The root component of the application. It manages the state for the entire application and orchestrates interactions between different components and the backend API.

2. **components/notes/**
   - **Note.tsx**: Displays an individual note and allows the user to edit or delete it.
   - **NoteList.tsx**: Displays a list of all notes. It receives data from the `useNotes` hook and renders `Note` components.
   - **NoteForm.tsx**: Contains a form to create new notes. It communicates with the `useNotes` hook to add new notes to the backend.
   
3. **hooks/useNotes.ts**
   - A custom hook that centralizes the logic for fetching, adding, updating, and deleting notes. It interacts directly with the backend API via the `api.ts` file.

4. **api/api.ts**
   - Centralized file for all API calls. It abstracts the HTTP requests used to interact with the backend and provides functions like `fetchNotes`, `createNote`, `updateNote`, and `deleteNote`.

5. **interfaces/types.ts**
   - Contains TypeScript interfaces such as `NoteType` and `NewNoteType` to ensure type safety across the application.

6. **theme/theme.ts**
   - Contains the application's theme settings for consistent styling across components.

## State Management and Data Flow

### Custom Hook: `useNotes`

The `useNotes` hook is the core of the frontend’s state management related to notes. It handles fetching, creating, updating, and deleting notes by interacting with the backend API.

- **State Variables**:
  - `notes`: An array of `NoteType` objects representing all notes.
  - `loading`: A boolean indicating if data is currently being fetched.
  - `error`: A string or `null` representing any error messages.

- **Functions**:
  - `getNotes`: Fetches all notes from the backend.
  - `addNote`: Sends a new note to the backend and updates the local state.
  - `editNote`: Updates an existing note both in the backend and in the local state.
  - `removeNote`: Deletes a note from the backend and removes it from the local state.

### Data Flow

1. **Fetching Data**:
   - When the application loads, `getNotes` is called to fetch all notes from the backend.
   - The notes are stored in the `notes` state and displayed using the `NoteList` component.

2. **Creating a New Note**:
   - The `NoteForm` component allows the user to create a new note.
   - On form submission, the `addNote` function from `useNotes` is called with the new note’s data.
   - The backend processes the new note, and the `notes` state is updated with the newly created note.

3. **Updating a Note**:
   - Each `Note` component includes an edit button that triggers a prompt for the user to edit the note’s title and content.
   - On submission, `editNote` is called with the updated data. The backend updates the note, and the local state is also updated to reflect these changes.

4. **Deleting a Note**:
   - Each `Note` component includes a delete button that triggers the `removeNote` function.
   - The note is deleted from the backend, and the local state is updated to remove the note from the UI.

## UI Components

### NoteList.tsx
- **Purpose**: Renders a list of notes by mapping over the `notes` state.
- **Props**: 
  - `notes`: An array of `NoteType` objects.
  - `editNote`: Function to update a note.
  - `deleteNote`: Function to delete a note.

### NoteForm.tsx
- **Purpose**: Provides a form for creating new notes.
- **State**:
  - `title`: Controls the title input field.
  - `content`: Controls the content input field.
- **Props**:
  - `addNote`: Function to add a new note.

### Note.tsx
- **Purpose**: Displays an individual note with options to edit or delete.
- **Props**:
  - `id`: The unique ID of the note.
  - `title`: The title of the note.
  - `content`: The content of the note.
  - `editNote`: Function to update the note.
  - `deleteNote`: Function to delete the note.

## Styling and Theming

The application uses Material-UI components combined with Emotion for custom styling. A central theme file (`theme.ts`) defines colors, spacing, and other design tokens to ensure consistency across the application.

### Theming
- **theme.ts**:
  - Defines primary and secondary colors, background colors, and text colors.
  - Includes utility functions for consistent spacing and typography across components.

### Custom Styled Components
- **StyledCard.tsx**: A styled card component that wraps each note, providing consistent styling like shadows, border-radius, and hover effects.

## Error Handling and User Feedback

- **Error States**:
  - The `useNotes` hook manages error states, which are displayed in the UI if any operation (fetching, creating, updating, deleting) fails.
  - The `error` state is displayed as a message in the UI, typically above the main content area.

- **Loading States**:
  - The `loading` state in `useNotes` ensures that users are informed when data is being fetched from the backend. During loading, a "Loading..." message is displayed.

## Authentication

All API requests made from the frontend include Basic Authentication headers. This is handled by appending the Base64-encoded username and password to the `Authorization` header in each API request.

Example:
```typescript
headers: {
  'Authorization': 'Basic ' + btoa('yourUsername:yourPassword'),
  'Content-Type': 'application/json',
}
```

## Conclusion

The Thought-to-Note Lite frontend is a well-organized React application that leverages modern development practices, including custom hooks for state management, centralized API interactions, and consistent styling through Material-UI and Emotion. The frontend interacts seamlessly with the backend to perform CRUD operations, providing a responsive and intuitive user experience for managing notes. 

This documentation provides an overview of the structure, components, and data flow within the frontend, helping developers understand and contribute to the application efficiently.
[File Ends] documentation.md

  [File Begins] public/index.html
  <!DOCTYPE html>
  <html lang="en">
    <head>
      <meta charset="utf-8" />
      <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
      <meta name="viewport" content="width=device-width, initial-scale=1" />
      <meta name="theme-color" content="#000000" />
      <meta
        name="description"
        content="Web site created using create-react-app"
      />
      <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
      <!--
        manifest.json provides metadata used when your web app is installed on a
        user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
      -->
      <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
      <!--
        Notice the use of %PUBLIC_URL% in the tags above.
        It will be replaced with the URL of the `public` folder during the build.
        Only files inside the `public` folder can be referenced from the HTML.
  
        Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
        work correctly both with client-side routing and a non-root public URL.
        Learn how to configure a non-root public URL by running `npm run build`.
      -->
      <title>React App</title>
    </head>
    <body>
      <noscript>You need to enable JavaScript to run this app.</noscript>
      <div id="root"></div>
      <!--
        This HTML file is a template.
        If you open it directly in the browser, you will see an empty page.
  
        You can add webfonts, meta tags, or analytics to this file.
        The build step will place the bundled scripts into the <body> tag.
  
        To begin the development, run `npm start` or `yarn start`.
        To create a production bundle, use `npm run build` or `yarn build`.
      -->
    </body>
  </html>

  [File Ends] public/index.html

  [File Begins] src/App.tsx
  import React, { useState } from 'react';
  import NoteList from './components/notes/NoteList';
  import NoteForm from './components/notes/NoteForm';
  import { Container, Typography, TextField, Button } from '@mui/material';
  import styled from '@emotion/styled';
  import useNotes from './hooks/useNotes';
  
  const AppContainer = styled(Container)`
    max-width: 800px;
    margin: 0 auto;
    padding: 2rem;
    background-color: #f9f9f9;
    border-radius: 12px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
  `;
  
  const SearchContainer = styled.div`
    display: flex;
    gap: 1rem;
    margin-bottom: 1.5rem;
  `;
  
  const App: React.FC = () => {
    const [searchQuery, setSearchQuery] = useState('');
    const { notes, loading, error, getNotes, addNote, editNote, removeNote, searchNotes } = useNotes();
  
    const handleSearch = async () => {
      if (searchQuery.trim() === '') {
        await getNotes(); // Call the getNotes function when searchQuery is empty
      } else {
        await searchNotes(searchQuery); // Otherwise, perform the search
      }
    };
  
    if (loading) return <p>Loading...</p>;
    if (error) return <p>{error}</p>;
  
    return (
      <AppContainer>
        <Typography variant="h4" align="center" gutterBottom>
          Thought to Note Lite
        </Typography>
  
        {/* Search Input */}
        <SearchContainer>
          <TextField
            label="Search by Title"
            variant="outlined"
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
            fullWidth
          />
          <Button variant="contained" color="primary" onClick={handleSearch}>
            Search
          </Button>
        </SearchContainer>
  
        <NoteForm addNote={addNote} />
        <NoteList notes={notes} editNote={editNote} deleteNote={removeNote} />
      </AppContainer>
    );
  };
  
  export default App;
  [File Ends] src/App.tsx

    [File Begins] src/api/api.ts
    import { NoteType, NewNoteType } from '../interfaces/types';
    
    const API_URL = 'http://localhost:8080/api/notes';
    
    export const fetchNotes = async (): Promise<NoteType[]> => {
      const response = await fetch(API_URL, {
        method: 'GET',
        headers: {
          'Authorization': 'Basic ' + btoa('yourUsername:yourPassword'),
          'Content-Type': 'application/json',
        },
      });
      if (!response.ok) throw new Error(response.statusText);
      return response.json();
    };
    
    export const createNote = async (newNote: NewNoteType): Promise<NoteType> => {
      const response = await fetch(API_URL, {
        method: 'POST',
        headers: {
          'Authorization': 'Basic ' + btoa('yourUsername:yourPassword'),
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(newNote),
      });
      if (!response.ok) throw new Error(response.statusText);
      return response.json(); // This will be of type NoteType
    };
    
    export const updateNote = async (id: number, updatedNote: NoteType): Promise<NoteType> => {
      const response = await fetch(`${API_URL}/${id}`, {
        method: 'PUT',
        headers: {
          'Authorization': 'Basic ' + btoa('yourUsername:yourPassword'),
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(updatedNote),
      });
      if (!response.ok) throw new Error(response.statusText);
      return response.json();
    };
    
    export const deleteNote = async (id: number): Promise<void> => {
      const response = await fetch(`${API_URL}/${id}`, {
        method: 'DELETE',
        headers: {
          'Authorization': 'Basic ' + btoa('yourUsername:yourPassword'),
        },
      });
      if (!response.ok) throw new Error(response.statusText);
    };
    [File Ends] src/api/api.ts

      [File Begins] src/components/notes/Note.tsx
      import React from 'react';
      import { CardContent, Typography, Button } from '@mui/material';
      import StyledCard from '../shared/StyledCard';
      import { NoteType } from '../../interfaces/types';
      
      interface NoteProps extends NoteType {
        editNote: (id: number, note: NoteType) => void;
        deleteNote: (id: number) => void;
      }
      
      const Note: React.FC<NoteProps> = ({ id, title, content, createdAt, updatedAt, editNote, deleteNote }) => {
        const handleEdit = () => {
          const updatedTitle = prompt('Edit Title', title);
          const updatedContent = prompt('Edit Content', content);
      
          if (updatedTitle !== null && updatedContent !== null) {
            // Pass all properties to maintain data integrity
            editNote(id, { id, title: updatedTitle, content: updatedContent, createdAt, updatedAt });
          }
        };
      
        const handleDelete = () => {
          if (window.confirm(`Are you sure you want to delete the note titled "${title}"?`)) {
            deleteNote(id);
          }
        };
      
        return (
          <StyledCard>
            <CardContent>
              <Typography variant="h6" gutterBottom>
                {title}
              </Typography>
              <Typography variant="body2" color="textSecondary">
                {content}
              </Typography>
              <div style={{ display: 'flex', justifyContent: 'space-between', marginTop: '0.5rem' }}>
                <Button size="small" color="primary" onClick={handleEdit}>
                  Edit
                </Button>
                <Button size="small" color="secondary" onClick={handleDelete}>
                  Delete
                </Button>
              </div>
            </CardContent>
          </StyledCard>
        );
      };
      
      export default Note;
      [File Ends] src/components/notes/Note.tsx

      [File Begins] src/components/notes/NoteForm.tsx
      import React, { useState } from 'react';
      import { TextField, Button } from '@mui/material';
      import styled from '@emotion/styled';
      import { NewNoteType } from '../../interfaces/types';
      
      const FormContainer = styled.form`
        display: flex;
        flex-direction: column;
        gap: 1rem;
        margin-bottom: 2rem;
      `;
      
      interface NoteFormProps {
        addNote: (note: NewNoteType) => void;
      }
      
      const NoteForm: React.FC<NoteFormProps> = ({ addNote }) => {
        const [title, setTitle] = useState('');
        const [content, setContent] = useState('');
      
        const handleSubmit = async (e: React.FormEvent) => {
          e.preventDefault();
      
          const newNote: NewNoteType = { title, content };
      
          try {
            addNote(newNote);
            setTitle('');
            setContent('');
          } catch (error) {
            console.error('Error creating note:', error);
          }
        };
      
        return (
          <FormContainer onSubmit={handleSubmit}>
            <TextField
              label="Title"
              variant="outlined"
              value={title}
              onChange={(e) => setTitle(e.target.value)}
              fullWidth
            />
            <TextField
              label="Content"
              variant="outlined"
              multiline
              rows={4}
              value={content}
              onChange={(e) => setContent(e.target.value)}
              fullWidth
            />
            <Button type="submit" variant="contained" color="primary">
              Save Note
            </Button>
          </FormContainer>
        );
      };
      
      export default NoteForm;
      [File Ends] src/components/notes/NoteForm.tsx

      [File Begins] src/components/notes/NoteList.tsx
      import React from 'react';
      import Note from './Note';
      import { Grid } from '@mui/material';
      import { NoteType } from '../../interfaces/types'; 
      
      interface NoteListProps {
        notes: NoteType[];
        editNote: (id: number, note: NoteType) => void;
        deleteNote: (id: number) => void;
      }
      
      const NoteList: React.FC<NoteListProps> = ({ notes, editNote, deleteNote }) => {
        return (
          <div style={{ marginTop: '2rem' }}>
            <Grid container spacing={2}>
              {notes.length > 0 ? (
                notes.map(note => (
                  <Grid item xs={12} sm={6} key={note.id}>
                    <Note {...note} editNote={editNote} deleteNote={deleteNote} />
                  </Grid>
                ))
              ) : (
                <p>No notes available.</p>
              )}
            </Grid>
          </div>
        );
      };
      
      export default NoteList;
      [File Ends] src/components/notes/NoteList.tsx

      [File Begins] src/components/shared/StyledCard.tsx
      import styled from '@emotion/styled';
      import { Card } from '@mui/material';
      import { theme } from '../../theme/theme';
      
      const StyledCard = styled(Card)`
        background-color: ${theme.colors.background};
        border-radius: 12px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
      
        &:hover {
          transform: translateY(-5px);
          box-shadow: 0 4px 16px rgba(0, 0, 0, 0.15);
        }
      `;
      
      export default StyledCard;
      [File Ends] src/components/shared/StyledCard.tsx

    [File Begins] src/hooks/useNotes.ts
    import { useState, useEffect } from 'react';
    import { NoteType, NewNoteType } from '../interfaces/types';
    import { fetchNotes, createNote, updateNote, deleteNote } from '../api/api';
    
    const useNotes = () => {
      const [notes, setNotes] = useState<NoteType[]>([]);
      const [loading, setLoading] = useState<boolean>(true);
      const [error, setError] = useState<string | null>(null);
    
      const getNotes = async () => {
        try {
          setLoading(true);
          setError(null); // Reset error before the operation
          const notes = await fetchNotes();
          setNotes(notes);
        } catch (err) {
          setError('An error occurred while fetching notes.');
        } finally {
          setLoading(false);
        }
      };
    
      const addNote = async (newNote: NewNoteType) => {
        try {
          setError(null); // Reset error before the operation
          const savedNote = await createNote(newNote);
          setNotes([...notes, savedNote]);
        } catch (err) {
          setError('An error occurred while adding the note.');
        }
      };
    
      const editNote = async (id: number, updatedNote: NoteType) => {
        try {
          setError(null); // Reset error before the operation
          const savedNote = await updateNote(id, updatedNote);
          setNotes(notes.map(note => (note.id === id ? savedNote : note)));
        } catch (err) {
          setError('An error occurred while updating the note.');
        }
      };
    
      const removeNote = async (id: number) => {
        try {
          setError(null); // Reset error before the operation
          await deleteNote(id);
          setNotes(notes.filter(note => note.id !== id));
        } catch (err) {
          setError('An error occurred while deleting the note.');
        }
      };
    
      const searchNotes = async (query: string) => {
        try {
          setLoading(true);
          setError(null); // Reset error before the operation
          const response = await fetch(`http://localhost:8080/api/notes/search?title=${encodeURIComponent(query)}`, {
            method: 'GET',
            headers: {
              'Authorization': 'Basic ' + btoa('yourUsername:yourPassword'),
              'Content-Type': 'application/json',
            },
          });
          
          if (response.ok) {
            const data = await response.json();
            setNotes(data);
          } else {
            setError('An error occurred while searching notes.');
          }
        } catch (err) {
          setError('An error occurred while searching notes.');
        } finally {
          setLoading(false);
        }
      };
    
      useEffect(() => {
        getNotes();  // Automatically fetch all notes when the component mounts
      }, []);
    
      return { notes, loading, error, getNotes, addNote, editNote, removeNote, searchNotes };
    };
    
    export default useNotes;
    [File Ends] src/hooks/useNotes.ts

  [File Begins] src/index.tsx
  import React from 'react';
  import ReactDOM from 'react-dom/client';
  import App from './App';
  
  const rootElement = document.getElementById('root');
  
  if (rootElement) {
    const root = ReactDOM.createRoot(rootElement);
    root.render(
      <React.StrictMode>
        <App />
      </React.StrictMode>
    );
  } else {
    console.error('Failed to find the root element.');
  }
  [File Ends] src/index.tsx

    [File Begins] src/interfaces/types.ts
    // Represents a complete note, as returned by the backend
    export interface NoteType {
      id: number;
      title: string;
      content: string;
      createdAt: string;
      updatedAt: string;
    }
    
    // Represents a new note being created, before it's saved by the backend. 
    // updatetAt and createdAt are not needed, since they are generated automatically by the Backend
    export interface NewNoteType {
      title: string;
      content: string;
    }
    
    
    export {};
    [File Ends] src/interfaces/types.ts

    [File Begins] src/theme/theme.ts
    export const theme = {
        colors: {
          primary: '#6200ea',
          secondary: '#03dac5',
          background: '#f9f9f9',
          text: '#000000',
        },
        spacing: (factor: number) => `${0.25 * factor}rem`,
      };
    [File Ends] src/theme/theme.ts

[File Begins] tsconfig.json
{
  "compilerOptions": {
    "target": "es5",
    "lib": [
      "dom",
      "dom.iterable",
      "esnext"
    ],
    "allowJs": true,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noFallthroughCasesInSwitch": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx"
  },
  "include": [
    "src"
  ]
}

[File Ends] tsconfig.json


<-- File Content Ends

